# 装饰器模式
    > 是指定义一个算法的骨 架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤，属于行为性设计模式。
    
#### 适用场景
	* 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
	* 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。
#### 在源码中的体现
	>  JDK 中的 AbstractList.get()是一个抽象方法，那么它的逻辑就是交给子类来实现，ArrayList 就是 AbstractList 的子类.同理，有 AbstractList 就有 AbstractSet 和AbstractMap，有兴趣的小伙伴可以去看看这些的源码实现。还有一个每天都在用的HttpServlet，有三个方法 service()和 doGet()、doPost()方法，都是模板方法的抽象实现。
#### 优点：
	1. 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。
	2. 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。
	3. 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。
#### 缺点：
	1. 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。
	2. 类数量的增加，间接地增加了系统实现的复杂度。
	3. 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。
    
### 思考：模板模式除了继承以外，还有哪些实现方式？
    > 模板模式主要是将不可变的部分固定起来，可变的部分放开，那么代理模式也可以做到这样，
    > 将不可变的部分固定成代理增强方法，可变的部分留给被代理类去做，不过这样模板被包装起来，不利于使用